grammar robot.ev3.Dsl with org.eclipse.xtext.common.Terminals

// next needed because of Ecore type EBoolean used
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate dls "http://www.ev3.robot/dsl"

/*
 * A mission consists of a number of behaviors
 */
Mission: behaviorList += Behavior+
;


/*
 * A behavior consists of a name, an optional type (in case of driving), an optional priority
 * and a take control definition.
 */
Behavior: 'Behavior:' name = ID
	'type:' behaviorType = BehaviorTypes?
	'priority:' prio = INT?
	'take-control:' control = TakeControl
	'actions:' actions = Actions
;

/*
 * Take control consists of either a boolean expression or a m
 */
TakeControl: takecontrol = BooleanExpression | MeasurableConditions;


/*
 * MeasurableConditions is a list of at least one measurable condition
 */
MeasurableConditions: measurableConditions += MeasurableCondition+;

/*
 * A measurable condition is a measurable, a value and an operator
 */
MeasurableCondition: (measurable = Measurables unit = MeasurementUnit value = STRING  operator = CompareOperator);


/*
 * Units of the measurements that can be performed
 */
enum MeasurementUnit:
	DISTANCE = "distance" |
	COLOR = "color" | 
	INT = "int"
;

/*
 * Types of behavior, only consists of driving
 */
enum BehaviorTypes:
	DRIVE = "drive"
;

/*
 * Measurement that can be performed by the sensors
 */
enum Measurables:
	FLOOR_COLOR = "floorColor" | 
	LEFT_TOUCH = "leftTouch"  |
	RIGHT_TOUCH = "rightTouch" |
	DIST_TO_OBJECT_FRONT = "distanceObjectInFront"
;

/*
 * Actions that can be performed
 */
enum Actions:
	ROTATE_L = "rotateLeft" |
	ROTATE_R = "rotateRight" |
	DRIVE_FORWARD = "driveForward" |
	DRIVE_BACKWARD = "driveBackward" |
	STOP_DRIVING = "stopDriving"
;


/*
 * Wind directions
 */
enum Directions:
	N = "N" |
	NE ="NE" |
	E = "E" |
	SE = "SE" | 
	S = "S" |
	SW = "SW" |
	W = "W" |
	NW = "NW"
;

/*
 * Predefined colors by LEJOS
 */
enum Colors:
	BLACK = "BLACK" |
	BLUE = "BLUE" |
	CYAN = "CYAN" |
	DARK_GRAY = "DARK_GRAY" | 
	GRAY = "GRAY" |
	GREEN = "GREEN" | 
	LIGHT_GRAY = "LIGHT_GRAY" | 
	MAGENTA = "MAGENTA" |
	ORANGE = "ORANGE" | 
	PINK = "PINK" | 
	RED = "RED" |
	WHITE = "WHITE" |
	YELLOW = "YELLOW"
;


/*
 * Integers Expression as defined in the manual
 */
IntExpression: ExpressionLevel1
;

ExpressionLevel1 returns IntExpression: // Left associativity
	ExpressionLevel2
	( ({ExpressionAddition.left =current} "+" right=ExpressionLevel2)
	| ({ExpressionSubtraction.left=current} "-" right=ExpressionLevel2)
	)*
;

ExpressionLevel2 returns IntExpression: // Left associativity
	ExpressionLevel3
	( ({ExpressionMultiply.left=current} "*" right=ExpressionLevel3)
	| ({ExpressionDivision.left=current} "/" right=ExpressionLevel3)
	| ({ExpressionMaximum.left =current} "max" right=ExpressionLevel3)
	| ({ExpressionMinimum.left =current} "min" right=ExpressionLevel3)
	| ({ExpressionModulo.left =current} "mod" right=ExpressionLevel3)
	)*
;

ExpressionLevel3 returns IntExpression: // Right associativity
	ExpressionLevel4
	( ({ExpressionPower.left=current} "^"
	right=ExpressionLevel3)
	)?
;

ExpressionLevel4 returns IntExpression:
	ExpressionMinus | ExpressionPlus | ExpressionLevel5
;

ExpressionMinus:
"-" sub=ExpressionLevel5
;

ExpressionPlus:
"+" sub=ExpressionLevel5
;

ExpressionLevel5 returns IntExpression:
	ExpressionBracket |
	ExpressionConstantInt
;

ExpressionBracket:
	"(" sub=IntExpression ")"
;

ExpressionConstantInt:
value=INT
;

/*
 * Boolean expression as defined in the manual
 */

BooleanExpression: BooleanExpressionLevel1
;

BooleanExpressionLevel1 returns BooleanExpression: // Left associativity
	BooleanExpressionLevel2
	( {ExpressionBinOp.left=current} bop = BinaryBooleanOperator
	right=BooleanExpressionLevel2
)*
;

enum BinaryBooleanOperator:
	AND = 'AND' |
	OR = 'OR'
;

BooleanExpressionLevel2 returns BooleanExpression:
	NotExpression |
	BooleanExpressionLevel3
;

NotExpression:
	"NOT" sub = BooleanExpressionLevel3
;
BooleanExpressionLevel3 returns BooleanExpression:
	(=> ComparisonExpression) |
	BooleanExpressionBracket |
	BooleanExpressionConstant
;

ComparisonExpression returns BooleanExpression: {ExpressionCompOp}
left=IntExpression op = CompareOperator right = IntExpression
;

enum CompareOperator:
	EQ = '==' |
	NEQ = '!=' |
	GEQ = '>=' |
	G = '>' |
	LEQ = '<=' |
	L = '<'
;

BooleanExpressionBracket:
"(" sub=BooleanExpression ")"
;

BooleanExpressionConstant:
value=BOOL_LITERAL
;

terminal BOOL_LITERAL returns ecore::EBoolean: 
	'true' | 'false' | 'TRUE' | 'FALSE'
;